// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/appointment"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/billingrecord"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/chatthread"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/clinic"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/clinicuser"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/doctor"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/document"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/inventorymovement"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/knowledgebase"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/order"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/patient"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/predicate"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/product"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/productcategory"
	"github.com/alfariiizi/vandor/internal/infrastructure/db/service"
	"github.com/google/uuid"
)

// ClinicUpdate is the builder for updating Clinic entities.
type ClinicUpdate struct {
	config
	hooks    []Hook
	mutation *ClinicMutation
}

// Where appends a list predicates to the ClinicUpdate builder.
func (cu *ClinicUpdate) Where(ps ...predicate.Clinic) *ClinicUpdate {
	cu.mutation.Where(ps...)
	return cu
}

// SetName sets the "name" field.
func (cu *ClinicUpdate) SetName(s string) *ClinicUpdate {
	cu.mutation.SetName(s)
	return cu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableName(s *string) *ClinicUpdate {
	if s != nil {
		cu.SetName(*s)
	}
	return cu
}

// SetType sets the "type" field.
func (cu *ClinicUpdate) SetType(s string) *ClinicUpdate {
	cu.mutation.SetType(s)
	return cu
}

// SetNillableType sets the "type" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableType(s *string) *ClinicUpdate {
	if s != nil {
		cu.SetType(*s)
	}
	return cu
}

// SetPhone sets the "phone" field.
func (cu *ClinicUpdate) SetPhone(s string) *ClinicUpdate {
	cu.mutation.SetPhone(s)
	return cu
}

// SetNillablePhone sets the "phone" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillablePhone(s *string) *ClinicUpdate {
	if s != nil {
		cu.SetPhone(*s)
	}
	return cu
}

// ClearPhone clears the value of the "phone" field.
func (cu *ClinicUpdate) ClearPhone() *ClinicUpdate {
	cu.mutation.ClearPhone()
	return cu
}

// SetEmail sets the "email" field.
func (cu *ClinicUpdate) SetEmail(s string) *ClinicUpdate {
	cu.mutation.SetEmail(s)
	return cu
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableEmail(s *string) *ClinicUpdate {
	if s != nil {
		cu.SetEmail(*s)
	}
	return cu
}

// ClearEmail clears the value of the "email" field.
func (cu *ClinicUpdate) ClearEmail() *ClinicUpdate {
	cu.mutation.ClearEmail()
	return cu
}

// SetAddress sets the "address" field.
func (cu *ClinicUpdate) SetAddress(s string) *ClinicUpdate {
	cu.mutation.SetAddress(s)
	return cu
}

// SetNillableAddress sets the "address" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableAddress(s *string) *ClinicUpdate {
	if s != nil {
		cu.SetAddress(*s)
	}
	return cu
}

// ClearAddress clears the value of the "address" field.
func (cu *ClinicUpdate) ClearAddress() *ClinicUpdate {
	cu.mutation.ClearAddress()
	return cu
}

// SetBusinessHours sets the "business_hours" field.
func (cu *ClinicUpdate) SetBusinessHours(m map[string]interface{}) *ClinicUpdate {
	cu.mutation.SetBusinessHours(m)
	return cu
}

// ClearBusinessHours clears the value of the "business_hours" field.
func (cu *ClinicUpdate) ClearBusinessHours() *ClinicUpdate {
	cu.mutation.ClearBusinessHours()
	return cu
}

// SetWhatsappNumber sets the "whatsapp_number" field.
func (cu *ClinicUpdate) SetWhatsappNumber(s string) *ClinicUpdate {
	cu.mutation.SetWhatsappNumber(s)
	return cu
}

// SetNillableWhatsappNumber sets the "whatsapp_number" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableWhatsappNumber(s *string) *ClinicUpdate {
	if s != nil {
		cu.SetWhatsappNumber(*s)
	}
	return cu
}

// ClearWhatsappNumber clears the value of the "whatsapp_number" field.
func (cu *ClinicUpdate) ClearWhatsappNumber() *ClinicUpdate {
	cu.mutation.ClearWhatsappNumber()
	return cu
}

// SetSubscriptionPlan sets the "subscription_plan" field.
func (cu *ClinicUpdate) SetSubscriptionPlan(s string) *ClinicUpdate {
	cu.mutation.SetSubscriptionPlan(s)
	return cu
}

// SetNillableSubscriptionPlan sets the "subscription_plan" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableSubscriptionPlan(s *string) *ClinicUpdate {
	if s != nil {
		cu.SetSubscriptionPlan(*s)
	}
	return cu
}

// SetEnabledFeatures sets the "enabled_features" field.
func (cu *ClinicUpdate) SetEnabledFeatures(s []string) *ClinicUpdate {
	cu.mutation.SetEnabledFeatures(s)
	return cu
}

// AppendEnabledFeatures appends s to the "enabled_features" field.
func (cu *ClinicUpdate) AppendEnabledFeatures(s []string) *ClinicUpdate {
	cu.mutation.AppendEnabledFeatures(s)
	return cu
}

// SetActive sets the "active" field.
func (cu *ClinicUpdate) SetActive(b bool) *ClinicUpdate {
	cu.mutation.SetActive(b)
	return cu
}

// SetNillableActive sets the "active" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableActive(b *bool) *ClinicUpdate {
	if b != nil {
		cu.SetActive(*b)
	}
	return cu
}

// SetCreatedAt sets the "created_at" field.
func (cu *ClinicUpdate) SetCreatedAt(t time.Time) *ClinicUpdate {
	cu.mutation.SetCreatedAt(t)
	return cu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (cu *ClinicUpdate) SetNillableCreatedAt(t *time.Time) *ClinicUpdate {
	if t != nil {
		cu.SetCreatedAt(*t)
	}
	return cu
}

// SetUpdatedAt sets the "updated_at" field.
func (cu *ClinicUpdate) SetUpdatedAt(t time.Time) *ClinicUpdate {
	cu.mutation.SetUpdatedAt(t)
	return cu
}

// AddClinicUserIDs adds the "clinic_users" edge to the ClinicUser entity by IDs.
func (cu *ClinicUpdate) AddClinicUserIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddClinicUserIDs(ids...)
	return cu
}

// AddClinicUsers adds the "clinic_users" edges to the ClinicUser entity.
func (cu *ClinicUpdate) AddClinicUsers(c ...*ClinicUser) *ClinicUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cu.AddClinicUserIDs(ids...)
}

// AddPatientIDs adds the "patients" edge to the Patient entity by IDs.
func (cu *ClinicUpdate) AddPatientIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddPatientIDs(ids...)
	return cu
}

// AddPatients adds the "patients" edges to the Patient entity.
func (cu *ClinicUpdate) AddPatients(p ...*Patient) *ClinicUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cu.AddPatientIDs(ids...)
}

// AddDoctorIDs adds the "doctors" edge to the Doctor entity by IDs.
func (cu *ClinicUpdate) AddDoctorIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddDoctorIDs(ids...)
	return cu
}

// AddDoctors adds the "doctors" edges to the Doctor entity.
func (cu *ClinicUpdate) AddDoctors(d ...*Doctor) *ClinicUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cu.AddDoctorIDs(ids...)
}

// AddServiceIDs adds the "services" edge to the Service entity by IDs.
func (cu *ClinicUpdate) AddServiceIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddServiceIDs(ids...)
	return cu
}

// AddServices adds the "services" edges to the Service entity.
func (cu *ClinicUpdate) AddServices(s ...*Service) *ClinicUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return cu.AddServiceIDs(ids...)
}

// AddAppointmentIDs adds the "appointments" edge to the Appointment entity by IDs.
func (cu *ClinicUpdate) AddAppointmentIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddAppointmentIDs(ids...)
	return cu
}

// AddAppointments adds the "appointments" edges to the Appointment entity.
func (cu *ClinicUpdate) AddAppointments(a ...*Appointment) *ClinicUpdate {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return cu.AddAppointmentIDs(ids...)
}

// AddChatThreadIDs adds the "chat_threads" edge to the ChatThread entity by IDs.
func (cu *ClinicUpdate) AddChatThreadIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddChatThreadIDs(ids...)
	return cu
}

// AddChatThreads adds the "chat_threads" edges to the ChatThread entity.
func (cu *ClinicUpdate) AddChatThreads(c ...*ChatThread) *ClinicUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cu.AddChatThreadIDs(ids...)
}

// AddKnowledgeBaseIDs adds the "knowledge_base" edge to the KnowledgeBase entity by IDs.
func (cu *ClinicUpdate) AddKnowledgeBaseIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddKnowledgeBaseIDs(ids...)
	return cu
}

// AddKnowledgeBase adds the "knowledge_base" edges to the KnowledgeBase entity.
func (cu *ClinicUpdate) AddKnowledgeBase(k ...*KnowledgeBase) *ClinicUpdate {
	ids := make([]uuid.UUID, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return cu.AddKnowledgeBaseIDs(ids...)
}

// AddBillingRecordIDs adds the "billing_records" edge to the BillingRecord entity by IDs.
func (cu *ClinicUpdate) AddBillingRecordIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddBillingRecordIDs(ids...)
	return cu
}

// AddBillingRecords adds the "billing_records" edges to the BillingRecord entity.
func (cu *ClinicUpdate) AddBillingRecords(b ...*BillingRecord) *ClinicUpdate {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return cu.AddBillingRecordIDs(ids...)
}

// AddDocumentIDs adds the "documents" edge to the Document entity by IDs.
func (cu *ClinicUpdate) AddDocumentIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddDocumentIDs(ids...)
	return cu
}

// AddDocuments adds the "documents" edges to the Document entity.
func (cu *ClinicUpdate) AddDocuments(d ...*Document) *ClinicUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cu.AddDocumentIDs(ids...)
}

// AddProductIDs adds the "products" edge to the Product entity by IDs.
func (cu *ClinicUpdate) AddProductIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddProductIDs(ids...)
	return cu
}

// AddProducts adds the "products" edges to the Product entity.
func (cu *ClinicUpdate) AddProducts(p ...*Product) *ClinicUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cu.AddProductIDs(ids...)
}

// AddProductCategoryIDs adds the "product_categories" edge to the ProductCategory entity by IDs.
func (cu *ClinicUpdate) AddProductCategoryIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddProductCategoryIDs(ids...)
	return cu
}

// AddProductCategories adds the "product_categories" edges to the ProductCategory entity.
func (cu *ClinicUpdate) AddProductCategories(p ...*ProductCategory) *ClinicUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cu.AddProductCategoryIDs(ids...)
}

// AddInventoryMovementIDs adds the "inventory_movements" edge to the InventoryMovement entity by IDs.
func (cu *ClinicUpdate) AddInventoryMovementIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddInventoryMovementIDs(ids...)
	return cu
}

// AddInventoryMovements adds the "inventory_movements" edges to the InventoryMovement entity.
func (cu *ClinicUpdate) AddInventoryMovements(i ...*InventoryMovement) *ClinicUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return cu.AddInventoryMovementIDs(ids...)
}

// AddOrderIDs adds the "orders" edge to the Order entity by IDs.
func (cu *ClinicUpdate) AddOrderIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.AddOrderIDs(ids...)
	return cu
}

// AddOrders adds the "orders" edges to the Order entity.
func (cu *ClinicUpdate) AddOrders(o ...*Order) *ClinicUpdate {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return cu.AddOrderIDs(ids...)
}

// Mutation returns the ClinicMutation object of the builder.
func (cu *ClinicUpdate) Mutation() *ClinicMutation {
	return cu.mutation
}

// ClearClinicUsers clears all "clinic_users" edges to the ClinicUser entity.
func (cu *ClinicUpdate) ClearClinicUsers() *ClinicUpdate {
	cu.mutation.ClearClinicUsers()
	return cu
}

// RemoveClinicUserIDs removes the "clinic_users" edge to ClinicUser entities by IDs.
func (cu *ClinicUpdate) RemoveClinicUserIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveClinicUserIDs(ids...)
	return cu
}

// RemoveClinicUsers removes "clinic_users" edges to ClinicUser entities.
func (cu *ClinicUpdate) RemoveClinicUsers(c ...*ClinicUser) *ClinicUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cu.RemoveClinicUserIDs(ids...)
}

// ClearPatients clears all "patients" edges to the Patient entity.
func (cu *ClinicUpdate) ClearPatients() *ClinicUpdate {
	cu.mutation.ClearPatients()
	return cu
}

// RemovePatientIDs removes the "patients" edge to Patient entities by IDs.
func (cu *ClinicUpdate) RemovePatientIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemovePatientIDs(ids...)
	return cu
}

// RemovePatients removes "patients" edges to Patient entities.
func (cu *ClinicUpdate) RemovePatients(p ...*Patient) *ClinicUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cu.RemovePatientIDs(ids...)
}

// ClearDoctors clears all "doctors" edges to the Doctor entity.
func (cu *ClinicUpdate) ClearDoctors() *ClinicUpdate {
	cu.mutation.ClearDoctors()
	return cu
}

// RemoveDoctorIDs removes the "doctors" edge to Doctor entities by IDs.
func (cu *ClinicUpdate) RemoveDoctorIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveDoctorIDs(ids...)
	return cu
}

// RemoveDoctors removes "doctors" edges to Doctor entities.
func (cu *ClinicUpdate) RemoveDoctors(d ...*Doctor) *ClinicUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cu.RemoveDoctorIDs(ids...)
}

// ClearServices clears all "services" edges to the Service entity.
func (cu *ClinicUpdate) ClearServices() *ClinicUpdate {
	cu.mutation.ClearServices()
	return cu
}

// RemoveServiceIDs removes the "services" edge to Service entities by IDs.
func (cu *ClinicUpdate) RemoveServiceIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveServiceIDs(ids...)
	return cu
}

// RemoveServices removes "services" edges to Service entities.
func (cu *ClinicUpdate) RemoveServices(s ...*Service) *ClinicUpdate {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return cu.RemoveServiceIDs(ids...)
}

// ClearAppointments clears all "appointments" edges to the Appointment entity.
func (cu *ClinicUpdate) ClearAppointments() *ClinicUpdate {
	cu.mutation.ClearAppointments()
	return cu
}

// RemoveAppointmentIDs removes the "appointments" edge to Appointment entities by IDs.
func (cu *ClinicUpdate) RemoveAppointmentIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveAppointmentIDs(ids...)
	return cu
}

// RemoveAppointments removes "appointments" edges to Appointment entities.
func (cu *ClinicUpdate) RemoveAppointments(a ...*Appointment) *ClinicUpdate {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return cu.RemoveAppointmentIDs(ids...)
}

// ClearChatThreads clears all "chat_threads" edges to the ChatThread entity.
func (cu *ClinicUpdate) ClearChatThreads() *ClinicUpdate {
	cu.mutation.ClearChatThreads()
	return cu
}

// RemoveChatThreadIDs removes the "chat_threads" edge to ChatThread entities by IDs.
func (cu *ClinicUpdate) RemoveChatThreadIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveChatThreadIDs(ids...)
	return cu
}

// RemoveChatThreads removes "chat_threads" edges to ChatThread entities.
func (cu *ClinicUpdate) RemoveChatThreads(c ...*ChatThread) *ClinicUpdate {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cu.RemoveChatThreadIDs(ids...)
}

// ClearKnowledgeBase clears all "knowledge_base" edges to the KnowledgeBase entity.
func (cu *ClinicUpdate) ClearKnowledgeBase() *ClinicUpdate {
	cu.mutation.ClearKnowledgeBase()
	return cu
}

// RemoveKnowledgeBaseIDs removes the "knowledge_base" edge to KnowledgeBase entities by IDs.
func (cu *ClinicUpdate) RemoveKnowledgeBaseIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveKnowledgeBaseIDs(ids...)
	return cu
}

// RemoveKnowledgeBase removes "knowledge_base" edges to KnowledgeBase entities.
func (cu *ClinicUpdate) RemoveKnowledgeBase(k ...*KnowledgeBase) *ClinicUpdate {
	ids := make([]uuid.UUID, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return cu.RemoveKnowledgeBaseIDs(ids...)
}

// ClearBillingRecords clears all "billing_records" edges to the BillingRecord entity.
func (cu *ClinicUpdate) ClearBillingRecords() *ClinicUpdate {
	cu.mutation.ClearBillingRecords()
	return cu
}

// RemoveBillingRecordIDs removes the "billing_records" edge to BillingRecord entities by IDs.
func (cu *ClinicUpdate) RemoveBillingRecordIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveBillingRecordIDs(ids...)
	return cu
}

// RemoveBillingRecords removes "billing_records" edges to BillingRecord entities.
func (cu *ClinicUpdate) RemoveBillingRecords(b ...*BillingRecord) *ClinicUpdate {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return cu.RemoveBillingRecordIDs(ids...)
}

// ClearDocuments clears all "documents" edges to the Document entity.
func (cu *ClinicUpdate) ClearDocuments() *ClinicUpdate {
	cu.mutation.ClearDocuments()
	return cu
}

// RemoveDocumentIDs removes the "documents" edge to Document entities by IDs.
func (cu *ClinicUpdate) RemoveDocumentIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveDocumentIDs(ids...)
	return cu
}

// RemoveDocuments removes "documents" edges to Document entities.
func (cu *ClinicUpdate) RemoveDocuments(d ...*Document) *ClinicUpdate {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cu.RemoveDocumentIDs(ids...)
}

// ClearProducts clears all "products" edges to the Product entity.
func (cu *ClinicUpdate) ClearProducts() *ClinicUpdate {
	cu.mutation.ClearProducts()
	return cu
}

// RemoveProductIDs removes the "products" edge to Product entities by IDs.
func (cu *ClinicUpdate) RemoveProductIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveProductIDs(ids...)
	return cu
}

// RemoveProducts removes "products" edges to Product entities.
func (cu *ClinicUpdate) RemoveProducts(p ...*Product) *ClinicUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cu.RemoveProductIDs(ids...)
}

// ClearProductCategories clears all "product_categories" edges to the ProductCategory entity.
func (cu *ClinicUpdate) ClearProductCategories() *ClinicUpdate {
	cu.mutation.ClearProductCategories()
	return cu
}

// RemoveProductCategoryIDs removes the "product_categories" edge to ProductCategory entities by IDs.
func (cu *ClinicUpdate) RemoveProductCategoryIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveProductCategoryIDs(ids...)
	return cu
}

// RemoveProductCategories removes "product_categories" edges to ProductCategory entities.
func (cu *ClinicUpdate) RemoveProductCategories(p ...*ProductCategory) *ClinicUpdate {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cu.RemoveProductCategoryIDs(ids...)
}

// ClearInventoryMovements clears all "inventory_movements" edges to the InventoryMovement entity.
func (cu *ClinicUpdate) ClearInventoryMovements() *ClinicUpdate {
	cu.mutation.ClearInventoryMovements()
	return cu
}

// RemoveInventoryMovementIDs removes the "inventory_movements" edge to InventoryMovement entities by IDs.
func (cu *ClinicUpdate) RemoveInventoryMovementIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveInventoryMovementIDs(ids...)
	return cu
}

// RemoveInventoryMovements removes "inventory_movements" edges to InventoryMovement entities.
func (cu *ClinicUpdate) RemoveInventoryMovements(i ...*InventoryMovement) *ClinicUpdate {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return cu.RemoveInventoryMovementIDs(ids...)
}

// ClearOrders clears all "orders" edges to the Order entity.
func (cu *ClinicUpdate) ClearOrders() *ClinicUpdate {
	cu.mutation.ClearOrders()
	return cu
}

// RemoveOrderIDs removes the "orders" edge to Order entities by IDs.
func (cu *ClinicUpdate) RemoveOrderIDs(ids ...uuid.UUID) *ClinicUpdate {
	cu.mutation.RemoveOrderIDs(ids...)
	return cu
}

// RemoveOrders removes "orders" edges to Order entities.
func (cu *ClinicUpdate) RemoveOrders(o ...*Order) *ClinicUpdate {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return cu.RemoveOrderIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (cu *ClinicUpdate) Save(ctx context.Context) (int, error) {
	cu.defaults()
	return withHooks(ctx, cu.sqlSave, cu.mutation, cu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (cu *ClinicUpdate) SaveX(ctx context.Context) int {
	affected, err := cu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (cu *ClinicUpdate) Exec(ctx context.Context) error {
	_, err := cu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (cu *ClinicUpdate) ExecX(ctx context.Context) {
	if err := cu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (cu *ClinicUpdate) defaults() {
	if _, ok := cu.mutation.UpdatedAt(); !ok {
		v := clinic.UpdateDefaultUpdatedAt()
		cu.mutation.SetUpdatedAt(v)
	}
}

func (cu *ClinicUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(clinic.Table, clinic.Columns, sqlgraph.NewFieldSpec(clinic.FieldID, field.TypeUUID))
	if ps := cu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := cu.mutation.Name(); ok {
		_spec.SetField(clinic.FieldName, field.TypeString, value)
	}
	if value, ok := cu.mutation.GetType(); ok {
		_spec.SetField(clinic.FieldType, field.TypeString, value)
	}
	if value, ok := cu.mutation.Phone(); ok {
		_spec.SetField(clinic.FieldPhone, field.TypeString, value)
	}
	if cu.mutation.PhoneCleared() {
		_spec.ClearField(clinic.FieldPhone, field.TypeString)
	}
	if value, ok := cu.mutation.Email(); ok {
		_spec.SetField(clinic.FieldEmail, field.TypeString, value)
	}
	if cu.mutation.EmailCleared() {
		_spec.ClearField(clinic.FieldEmail, field.TypeString)
	}
	if value, ok := cu.mutation.Address(); ok {
		_spec.SetField(clinic.FieldAddress, field.TypeString, value)
	}
	if cu.mutation.AddressCleared() {
		_spec.ClearField(clinic.FieldAddress, field.TypeString)
	}
	if value, ok := cu.mutation.BusinessHours(); ok {
		_spec.SetField(clinic.FieldBusinessHours, field.TypeJSON, value)
	}
	if cu.mutation.BusinessHoursCleared() {
		_spec.ClearField(clinic.FieldBusinessHours, field.TypeJSON)
	}
	if value, ok := cu.mutation.WhatsappNumber(); ok {
		_spec.SetField(clinic.FieldWhatsappNumber, field.TypeString, value)
	}
	if cu.mutation.WhatsappNumberCleared() {
		_spec.ClearField(clinic.FieldWhatsappNumber, field.TypeString)
	}
	if value, ok := cu.mutation.SubscriptionPlan(); ok {
		_spec.SetField(clinic.FieldSubscriptionPlan, field.TypeString, value)
	}
	if value, ok := cu.mutation.EnabledFeatures(); ok {
		_spec.SetField(clinic.FieldEnabledFeatures, field.TypeJSON, value)
	}
	if value, ok := cu.mutation.AppendedEnabledFeatures(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, clinic.FieldEnabledFeatures, value)
		})
	}
	if value, ok := cu.mutation.Active(); ok {
		_spec.SetField(clinic.FieldActive, field.TypeBool, value)
	}
	if value, ok := cu.mutation.CreatedAt(); ok {
		_spec.SetField(clinic.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := cu.mutation.UpdatedAt(); ok {
		_spec.SetField(clinic.FieldUpdatedAt, field.TypeTime, value)
	}
	if cu.mutation.ClinicUsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ClinicUsersTable,
			Columns: []string{clinic.ClinicUsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(clinicuser.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedClinicUsersIDs(); len(nodes) > 0 && !cu.mutation.ClinicUsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ClinicUsersTable,
			Columns: []string{clinic.ClinicUsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(clinicuser.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.ClinicUsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ClinicUsersTable,
			Columns: []string{clinic.ClinicUsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(clinicuser.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.PatientsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.PatientsTable,
			Columns: []string{clinic.PatientsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(patient.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedPatientsIDs(); len(nodes) > 0 && !cu.mutation.PatientsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.PatientsTable,
			Columns: []string{clinic.PatientsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(patient.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.PatientsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.PatientsTable,
			Columns: []string{clinic.PatientsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(patient.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.DoctorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DoctorsTable,
			Columns: []string{clinic.DoctorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(doctor.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedDoctorsIDs(); len(nodes) > 0 && !cu.mutation.DoctorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DoctorsTable,
			Columns: []string{clinic.DoctorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(doctor.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.DoctorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DoctorsTable,
			Columns: []string{clinic.DoctorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(doctor.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.ServicesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ServicesTable,
			Columns: []string{clinic.ServicesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(service.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedServicesIDs(); len(nodes) > 0 && !cu.mutation.ServicesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ServicesTable,
			Columns: []string{clinic.ServicesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(service.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.ServicesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ServicesTable,
			Columns: []string{clinic.ServicesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(service.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.AppointmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.AppointmentsTable,
			Columns: []string{clinic.AppointmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(appointment.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedAppointmentsIDs(); len(nodes) > 0 && !cu.mutation.AppointmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.AppointmentsTable,
			Columns: []string{clinic.AppointmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(appointment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.AppointmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.AppointmentsTable,
			Columns: []string{clinic.AppointmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(appointment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.ChatThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ChatThreadsTable,
			Columns: []string{clinic.ChatThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chatthread.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedChatThreadsIDs(); len(nodes) > 0 && !cu.mutation.ChatThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ChatThreadsTable,
			Columns: []string{clinic.ChatThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chatthread.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.ChatThreadsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ChatThreadsTable,
			Columns: []string{clinic.ChatThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chatthread.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.KnowledgeBaseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.KnowledgeBaseTable,
			Columns: []string{clinic.KnowledgeBaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(knowledgebase.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedKnowledgeBaseIDs(); len(nodes) > 0 && !cu.mutation.KnowledgeBaseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.KnowledgeBaseTable,
			Columns: []string{clinic.KnowledgeBaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(knowledgebase.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.KnowledgeBaseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.KnowledgeBaseTable,
			Columns: []string{clinic.KnowledgeBaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(knowledgebase.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.BillingRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.BillingRecordsTable,
			Columns: []string{clinic.BillingRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billingrecord.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedBillingRecordsIDs(); len(nodes) > 0 && !cu.mutation.BillingRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.BillingRecordsTable,
			Columns: []string{clinic.BillingRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billingrecord.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.BillingRecordsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.BillingRecordsTable,
			Columns: []string{clinic.BillingRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billingrecord.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.DocumentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DocumentsTable,
			Columns: []string{clinic.DocumentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(document.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedDocumentsIDs(); len(nodes) > 0 && !cu.mutation.DocumentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DocumentsTable,
			Columns: []string{clinic.DocumentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(document.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.DocumentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DocumentsTable,
			Columns: []string{clinic.DocumentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(document.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.ProductsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductsTable,
			Columns: []string{clinic.ProductsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(product.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedProductsIDs(); len(nodes) > 0 && !cu.mutation.ProductsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductsTable,
			Columns: []string{clinic.ProductsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(product.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.ProductsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductsTable,
			Columns: []string{clinic.ProductsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(product.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.ProductCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductCategoriesTable,
			Columns: []string{clinic.ProductCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productcategory.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedProductCategoriesIDs(); len(nodes) > 0 && !cu.mutation.ProductCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductCategoriesTable,
			Columns: []string{clinic.ProductCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productcategory.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.ProductCategoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductCategoriesTable,
			Columns: []string{clinic.ProductCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productcategory.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.InventoryMovementsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.InventoryMovementsTable,
			Columns: []string{clinic.InventoryMovementsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inventorymovement.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedInventoryMovementsIDs(); len(nodes) > 0 && !cu.mutation.InventoryMovementsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.InventoryMovementsTable,
			Columns: []string{clinic.InventoryMovementsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inventorymovement.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.InventoryMovementsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.InventoryMovementsTable,
			Columns: []string{clinic.InventoryMovementsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inventorymovement.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cu.mutation.OrdersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.OrdersTable,
			Columns: []string{clinic.OrdersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(order.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.RemovedOrdersIDs(); len(nodes) > 0 && !cu.mutation.OrdersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.OrdersTable,
			Columns: []string{clinic.OrdersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(order.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cu.mutation.OrdersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.OrdersTable,
			Columns: []string{clinic.OrdersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(order.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, cu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{clinic.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	cu.mutation.done = true
	return n, nil
}

// ClinicUpdateOne is the builder for updating a single Clinic entity.
type ClinicUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ClinicMutation
}

// SetName sets the "name" field.
func (cuo *ClinicUpdateOne) SetName(s string) *ClinicUpdateOne {
	cuo.mutation.SetName(s)
	return cuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableName(s *string) *ClinicUpdateOne {
	if s != nil {
		cuo.SetName(*s)
	}
	return cuo
}

// SetType sets the "type" field.
func (cuo *ClinicUpdateOne) SetType(s string) *ClinicUpdateOne {
	cuo.mutation.SetType(s)
	return cuo
}

// SetNillableType sets the "type" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableType(s *string) *ClinicUpdateOne {
	if s != nil {
		cuo.SetType(*s)
	}
	return cuo
}

// SetPhone sets the "phone" field.
func (cuo *ClinicUpdateOne) SetPhone(s string) *ClinicUpdateOne {
	cuo.mutation.SetPhone(s)
	return cuo
}

// SetNillablePhone sets the "phone" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillablePhone(s *string) *ClinicUpdateOne {
	if s != nil {
		cuo.SetPhone(*s)
	}
	return cuo
}

// ClearPhone clears the value of the "phone" field.
func (cuo *ClinicUpdateOne) ClearPhone() *ClinicUpdateOne {
	cuo.mutation.ClearPhone()
	return cuo
}

// SetEmail sets the "email" field.
func (cuo *ClinicUpdateOne) SetEmail(s string) *ClinicUpdateOne {
	cuo.mutation.SetEmail(s)
	return cuo
}

// SetNillableEmail sets the "email" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableEmail(s *string) *ClinicUpdateOne {
	if s != nil {
		cuo.SetEmail(*s)
	}
	return cuo
}

// ClearEmail clears the value of the "email" field.
func (cuo *ClinicUpdateOne) ClearEmail() *ClinicUpdateOne {
	cuo.mutation.ClearEmail()
	return cuo
}

// SetAddress sets the "address" field.
func (cuo *ClinicUpdateOne) SetAddress(s string) *ClinicUpdateOne {
	cuo.mutation.SetAddress(s)
	return cuo
}

// SetNillableAddress sets the "address" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableAddress(s *string) *ClinicUpdateOne {
	if s != nil {
		cuo.SetAddress(*s)
	}
	return cuo
}

// ClearAddress clears the value of the "address" field.
func (cuo *ClinicUpdateOne) ClearAddress() *ClinicUpdateOne {
	cuo.mutation.ClearAddress()
	return cuo
}

// SetBusinessHours sets the "business_hours" field.
func (cuo *ClinicUpdateOne) SetBusinessHours(m map[string]interface{}) *ClinicUpdateOne {
	cuo.mutation.SetBusinessHours(m)
	return cuo
}

// ClearBusinessHours clears the value of the "business_hours" field.
func (cuo *ClinicUpdateOne) ClearBusinessHours() *ClinicUpdateOne {
	cuo.mutation.ClearBusinessHours()
	return cuo
}

// SetWhatsappNumber sets the "whatsapp_number" field.
func (cuo *ClinicUpdateOne) SetWhatsappNumber(s string) *ClinicUpdateOne {
	cuo.mutation.SetWhatsappNumber(s)
	return cuo
}

// SetNillableWhatsappNumber sets the "whatsapp_number" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableWhatsappNumber(s *string) *ClinicUpdateOne {
	if s != nil {
		cuo.SetWhatsappNumber(*s)
	}
	return cuo
}

// ClearWhatsappNumber clears the value of the "whatsapp_number" field.
func (cuo *ClinicUpdateOne) ClearWhatsappNumber() *ClinicUpdateOne {
	cuo.mutation.ClearWhatsappNumber()
	return cuo
}

// SetSubscriptionPlan sets the "subscription_plan" field.
func (cuo *ClinicUpdateOne) SetSubscriptionPlan(s string) *ClinicUpdateOne {
	cuo.mutation.SetSubscriptionPlan(s)
	return cuo
}

// SetNillableSubscriptionPlan sets the "subscription_plan" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableSubscriptionPlan(s *string) *ClinicUpdateOne {
	if s != nil {
		cuo.SetSubscriptionPlan(*s)
	}
	return cuo
}

// SetEnabledFeatures sets the "enabled_features" field.
func (cuo *ClinicUpdateOne) SetEnabledFeatures(s []string) *ClinicUpdateOne {
	cuo.mutation.SetEnabledFeatures(s)
	return cuo
}

// AppendEnabledFeatures appends s to the "enabled_features" field.
func (cuo *ClinicUpdateOne) AppendEnabledFeatures(s []string) *ClinicUpdateOne {
	cuo.mutation.AppendEnabledFeatures(s)
	return cuo
}

// SetActive sets the "active" field.
func (cuo *ClinicUpdateOne) SetActive(b bool) *ClinicUpdateOne {
	cuo.mutation.SetActive(b)
	return cuo
}

// SetNillableActive sets the "active" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableActive(b *bool) *ClinicUpdateOne {
	if b != nil {
		cuo.SetActive(*b)
	}
	return cuo
}

// SetCreatedAt sets the "created_at" field.
func (cuo *ClinicUpdateOne) SetCreatedAt(t time.Time) *ClinicUpdateOne {
	cuo.mutation.SetCreatedAt(t)
	return cuo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (cuo *ClinicUpdateOne) SetNillableCreatedAt(t *time.Time) *ClinicUpdateOne {
	if t != nil {
		cuo.SetCreatedAt(*t)
	}
	return cuo
}

// SetUpdatedAt sets the "updated_at" field.
func (cuo *ClinicUpdateOne) SetUpdatedAt(t time.Time) *ClinicUpdateOne {
	cuo.mutation.SetUpdatedAt(t)
	return cuo
}

// AddClinicUserIDs adds the "clinic_users" edge to the ClinicUser entity by IDs.
func (cuo *ClinicUpdateOne) AddClinicUserIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddClinicUserIDs(ids...)
	return cuo
}

// AddClinicUsers adds the "clinic_users" edges to the ClinicUser entity.
func (cuo *ClinicUpdateOne) AddClinicUsers(c ...*ClinicUser) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cuo.AddClinicUserIDs(ids...)
}

// AddPatientIDs adds the "patients" edge to the Patient entity by IDs.
func (cuo *ClinicUpdateOne) AddPatientIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddPatientIDs(ids...)
	return cuo
}

// AddPatients adds the "patients" edges to the Patient entity.
func (cuo *ClinicUpdateOne) AddPatients(p ...*Patient) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cuo.AddPatientIDs(ids...)
}

// AddDoctorIDs adds the "doctors" edge to the Doctor entity by IDs.
func (cuo *ClinicUpdateOne) AddDoctorIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddDoctorIDs(ids...)
	return cuo
}

// AddDoctors adds the "doctors" edges to the Doctor entity.
func (cuo *ClinicUpdateOne) AddDoctors(d ...*Doctor) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cuo.AddDoctorIDs(ids...)
}

// AddServiceIDs adds the "services" edge to the Service entity by IDs.
func (cuo *ClinicUpdateOne) AddServiceIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddServiceIDs(ids...)
	return cuo
}

// AddServices adds the "services" edges to the Service entity.
func (cuo *ClinicUpdateOne) AddServices(s ...*Service) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return cuo.AddServiceIDs(ids...)
}

// AddAppointmentIDs adds the "appointments" edge to the Appointment entity by IDs.
func (cuo *ClinicUpdateOne) AddAppointmentIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddAppointmentIDs(ids...)
	return cuo
}

// AddAppointments adds the "appointments" edges to the Appointment entity.
func (cuo *ClinicUpdateOne) AddAppointments(a ...*Appointment) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return cuo.AddAppointmentIDs(ids...)
}

// AddChatThreadIDs adds the "chat_threads" edge to the ChatThread entity by IDs.
func (cuo *ClinicUpdateOne) AddChatThreadIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddChatThreadIDs(ids...)
	return cuo
}

// AddChatThreads adds the "chat_threads" edges to the ChatThread entity.
func (cuo *ClinicUpdateOne) AddChatThreads(c ...*ChatThread) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cuo.AddChatThreadIDs(ids...)
}

// AddKnowledgeBaseIDs adds the "knowledge_base" edge to the KnowledgeBase entity by IDs.
func (cuo *ClinicUpdateOne) AddKnowledgeBaseIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddKnowledgeBaseIDs(ids...)
	return cuo
}

// AddKnowledgeBase adds the "knowledge_base" edges to the KnowledgeBase entity.
func (cuo *ClinicUpdateOne) AddKnowledgeBase(k ...*KnowledgeBase) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return cuo.AddKnowledgeBaseIDs(ids...)
}

// AddBillingRecordIDs adds the "billing_records" edge to the BillingRecord entity by IDs.
func (cuo *ClinicUpdateOne) AddBillingRecordIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddBillingRecordIDs(ids...)
	return cuo
}

// AddBillingRecords adds the "billing_records" edges to the BillingRecord entity.
func (cuo *ClinicUpdateOne) AddBillingRecords(b ...*BillingRecord) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return cuo.AddBillingRecordIDs(ids...)
}

// AddDocumentIDs adds the "documents" edge to the Document entity by IDs.
func (cuo *ClinicUpdateOne) AddDocumentIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddDocumentIDs(ids...)
	return cuo
}

// AddDocuments adds the "documents" edges to the Document entity.
func (cuo *ClinicUpdateOne) AddDocuments(d ...*Document) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cuo.AddDocumentIDs(ids...)
}

// AddProductIDs adds the "products" edge to the Product entity by IDs.
func (cuo *ClinicUpdateOne) AddProductIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddProductIDs(ids...)
	return cuo
}

// AddProducts adds the "products" edges to the Product entity.
func (cuo *ClinicUpdateOne) AddProducts(p ...*Product) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cuo.AddProductIDs(ids...)
}

// AddProductCategoryIDs adds the "product_categories" edge to the ProductCategory entity by IDs.
func (cuo *ClinicUpdateOne) AddProductCategoryIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddProductCategoryIDs(ids...)
	return cuo
}

// AddProductCategories adds the "product_categories" edges to the ProductCategory entity.
func (cuo *ClinicUpdateOne) AddProductCategories(p ...*ProductCategory) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cuo.AddProductCategoryIDs(ids...)
}

// AddInventoryMovementIDs adds the "inventory_movements" edge to the InventoryMovement entity by IDs.
func (cuo *ClinicUpdateOne) AddInventoryMovementIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddInventoryMovementIDs(ids...)
	return cuo
}

// AddInventoryMovements adds the "inventory_movements" edges to the InventoryMovement entity.
func (cuo *ClinicUpdateOne) AddInventoryMovements(i ...*InventoryMovement) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return cuo.AddInventoryMovementIDs(ids...)
}

// AddOrderIDs adds the "orders" edge to the Order entity by IDs.
func (cuo *ClinicUpdateOne) AddOrderIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.AddOrderIDs(ids...)
	return cuo
}

// AddOrders adds the "orders" edges to the Order entity.
func (cuo *ClinicUpdateOne) AddOrders(o ...*Order) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return cuo.AddOrderIDs(ids...)
}

// Mutation returns the ClinicMutation object of the builder.
func (cuo *ClinicUpdateOne) Mutation() *ClinicMutation {
	return cuo.mutation
}

// ClearClinicUsers clears all "clinic_users" edges to the ClinicUser entity.
func (cuo *ClinicUpdateOne) ClearClinicUsers() *ClinicUpdateOne {
	cuo.mutation.ClearClinicUsers()
	return cuo
}

// RemoveClinicUserIDs removes the "clinic_users" edge to ClinicUser entities by IDs.
func (cuo *ClinicUpdateOne) RemoveClinicUserIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveClinicUserIDs(ids...)
	return cuo
}

// RemoveClinicUsers removes "clinic_users" edges to ClinicUser entities.
func (cuo *ClinicUpdateOne) RemoveClinicUsers(c ...*ClinicUser) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cuo.RemoveClinicUserIDs(ids...)
}

// ClearPatients clears all "patients" edges to the Patient entity.
func (cuo *ClinicUpdateOne) ClearPatients() *ClinicUpdateOne {
	cuo.mutation.ClearPatients()
	return cuo
}

// RemovePatientIDs removes the "patients" edge to Patient entities by IDs.
func (cuo *ClinicUpdateOne) RemovePatientIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemovePatientIDs(ids...)
	return cuo
}

// RemovePatients removes "patients" edges to Patient entities.
func (cuo *ClinicUpdateOne) RemovePatients(p ...*Patient) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cuo.RemovePatientIDs(ids...)
}

// ClearDoctors clears all "doctors" edges to the Doctor entity.
func (cuo *ClinicUpdateOne) ClearDoctors() *ClinicUpdateOne {
	cuo.mutation.ClearDoctors()
	return cuo
}

// RemoveDoctorIDs removes the "doctors" edge to Doctor entities by IDs.
func (cuo *ClinicUpdateOne) RemoveDoctorIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveDoctorIDs(ids...)
	return cuo
}

// RemoveDoctors removes "doctors" edges to Doctor entities.
func (cuo *ClinicUpdateOne) RemoveDoctors(d ...*Doctor) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cuo.RemoveDoctorIDs(ids...)
}

// ClearServices clears all "services" edges to the Service entity.
func (cuo *ClinicUpdateOne) ClearServices() *ClinicUpdateOne {
	cuo.mutation.ClearServices()
	return cuo
}

// RemoveServiceIDs removes the "services" edge to Service entities by IDs.
func (cuo *ClinicUpdateOne) RemoveServiceIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveServiceIDs(ids...)
	return cuo
}

// RemoveServices removes "services" edges to Service entities.
func (cuo *ClinicUpdateOne) RemoveServices(s ...*Service) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return cuo.RemoveServiceIDs(ids...)
}

// ClearAppointments clears all "appointments" edges to the Appointment entity.
func (cuo *ClinicUpdateOne) ClearAppointments() *ClinicUpdateOne {
	cuo.mutation.ClearAppointments()
	return cuo
}

// RemoveAppointmentIDs removes the "appointments" edge to Appointment entities by IDs.
func (cuo *ClinicUpdateOne) RemoveAppointmentIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveAppointmentIDs(ids...)
	return cuo
}

// RemoveAppointments removes "appointments" edges to Appointment entities.
func (cuo *ClinicUpdateOne) RemoveAppointments(a ...*Appointment) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return cuo.RemoveAppointmentIDs(ids...)
}

// ClearChatThreads clears all "chat_threads" edges to the ChatThread entity.
func (cuo *ClinicUpdateOne) ClearChatThreads() *ClinicUpdateOne {
	cuo.mutation.ClearChatThreads()
	return cuo
}

// RemoveChatThreadIDs removes the "chat_threads" edge to ChatThread entities by IDs.
func (cuo *ClinicUpdateOne) RemoveChatThreadIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveChatThreadIDs(ids...)
	return cuo
}

// RemoveChatThreads removes "chat_threads" edges to ChatThread entities.
func (cuo *ClinicUpdateOne) RemoveChatThreads(c ...*ChatThread) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return cuo.RemoveChatThreadIDs(ids...)
}

// ClearKnowledgeBase clears all "knowledge_base" edges to the KnowledgeBase entity.
func (cuo *ClinicUpdateOne) ClearKnowledgeBase() *ClinicUpdateOne {
	cuo.mutation.ClearKnowledgeBase()
	return cuo
}

// RemoveKnowledgeBaseIDs removes the "knowledge_base" edge to KnowledgeBase entities by IDs.
func (cuo *ClinicUpdateOne) RemoveKnowledgeBaseIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveKnowledgeBaseIDs(ids...)
	return cuo
}

// RemoveKnowledgeBase removes "knowledge_base" edges to KnowledgeBase entities.
func (cuo *ClinicUpdateOne) RemoveKnowledgeBase(k ...*KnowledgeBase) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(k))
	for i := range k {
		ids[i] = k[i].ID
	}
	return cuo.RemoveKnowledgeBaseIDs(ids...)
}

// ClearBillingRecords clears all "billing_records" edges to the BillingRecord entity.
func (cuo *ClinicUpdateOne) ClearBillingRecords() *ClinicUpdateOne {
	cuo.mutation.ClearBillingRecords()
	return cuo
}

// RemoveBillingRecordIDs removes the "billing_records" edge to BillingRecord entities by IDs.
func (cuo *ClinicUpdateOne) RemoveBillingRecordIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveBillingRecordIDs(ids...)
	return cuo
}

// RemoveBillingRecords removes "billing_records" edges to BillingRecord entities.
func (cuo *ClinicUpdateOne) RemoveBillingRecords(b ...*BillingRecord) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(b))
	for i := range b {
		ids[i] = b[i].ID
	}
	return cuo.RemoveBillingRecordIDs(ids...)
}

// ClearDocuments clears all "documents" edges to the Document entity.
func (cuo *ClinicUpdateOne) ClearDocuments() *ClinicUpdateOne {
	cuo.mutation.ClearDocuments()
	return cuo
}

// RemoveDocumentIDs removes the "documents" edge to Document entities by IDs.
func (cuo *ClinicUpdateOne) RemoveDocumentIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveDocumentIDs(ids...)
	return cuo
}

// RemoveDocuments removes "documents" edges to Document entities.
func (cuo *ClinicUpdateOne) RemoveDocuments(d ...*Document) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return cuo.RemoveDocumentIDs(ids...)
}

// ClearProducts clears all "products" edges to the Product entity.
func (cuo *ClinicUpdateOne) ClearProducts() *ClinicUpdateOne {
	cuo.mutation.ClearProducts()
	return cuo
}

// RemoveProductIDs removes the "products" edge to Product entities by IDs.
func (cuo *ClinicUpdateOne) RemoveProductIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveProductIDs(ids...)
	return cuo
}

// RemoveProducts removes "products" edges to Product entities.
func (cuo *ClinicUpdateOne) RemoveProducts(p ...*Product) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cuo.RemoveProductIDs(ids...)
}

// ClearProductCategories clears all "product_categories" edges to the ProductCategory entity.
func (cuo *ClinicUpdateOne) ClearProductCategories() *ClinicUpdateOne {
	cuo.mutation.ClearProductCategories()
	return cuo
}

// RemoveProductCategoryIDs removes the "product_categories" edge to ProductCategory entities by IDs.
func (cuo *ClinicUpdateOne) RemoveProductCategoryIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveProductCategoryIDs(ids...)
	return cuo
}

// RemoveProductCategories removes "product_categories" edges to ProductCategory entities.
func (cuo *ClinicUpdateOne) RemoveProductCategories(p ...*ProductCategory) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(p))
	for i := range p {
		ids[i] = p[i].ID
	}
	return cuo.RemoveProductCategoryIDs(ids...)
}

// ClearInventoryMovements clears all "inventory_movements" edges to the InventoryMovement entity.
func (cuo *ClinicUpdateOne) ClearInventoryMovements() *ClinicUpdateOne {
	cuo.mutation.ClearInventoryMovements()
	return cuo
}

// RemoveInventoryMovementIDs removes the "inventory_movements" edge to InventoryMovement entities by IDs.
func (cuo *ClinicUpdateOne) RemoveInventoryMovementIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveInventoryMovementIDs(ids...)
	return cuo
}

// RemoveInventoryMovements removes "inventory_movements" edges to InventoryMovement entities.
func (cuo *ClinicUpdateOne) RemoveInventoryMovements(i ...*InventoryMovement) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return cuo.RemoveInventoryMovementIDs(ids...)
}

// ClearOrders clears all "orders" edges to the Order entity.
func (cuo *ClinicUpdateOne) ClearOrders() *ClinicUpdateOne {
	cuo.mutation.ClearOrders()
	return cuo
}

// RemoveOrderIDs removes the "orders" edge to Order entities by IDs.
func (cuo *ClinicUpdateOne) RemoveOrderIDs(ids ...uuid.UUID) *ClinicUpdateOne {
	cuo.mutation.RemoveOrderIDs(ids...)
	return cuo
}

// RemoveOrders removes "orders" edges to Order entities.
func (cuo *ClinicUpdateOne) RemoveOrders(o ...*Order) *ClinicUpdateOne {
	ids := make([]uuid.UUID, len(o))
	for i := range o {
		ids[i] = o[i].ID
	}
	return cuo.RemoveOrderIDs(ids...)
}

// Where appends a list predicates to the ClinicUpdate builder.
func (cuo *ClinicUpdateOne) Where(ps ...predicate.Clinic) *ClinicUpdateOne {
	cuo.mutation.Where(ps...)
	return cuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (cuo *ClinicUpdateOne) Select(field string, fields ...string) *ClinicUpdateOne {
	cuo.fields = append([]string{field}, fields...)
	return cuo
}

// Save executes the query and returns the updated Clinic entity.
func (cuo *ClinicUpdateOne) Save(ctx context.Context) (*Clinic, error) {
	cuo.defaults()
	return withHooks(ctx, cuo.sqlSave, cuo.mutation, cuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (cuo *ClinicUpdateOne) SaveX(ctx context.Context) *Clinic {
	node, err := cuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (cuo *ClinicUpdateOne) Exec(ctx context.Context) error {
	_, err := cuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (cuo *ClinicUpdateOne) ExecX(ctx context.Context) {
	if err := cuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (cuo *ClinicUpdateOne) defaults() {
	if _, ok := cuo.mutation.UpdatedAt(); !ok {
		v := clinic.UpdateDefaultUpdatedAt()
		cuo.mutation.SetUpdatedAt(v)
	}
}

func (cuo *ClinicUpdateOne) sqlSave(ctx context.Context) (_node *Clinic, err error) {
	_spec := sqlgraph.NewUpdateSpec(clinic.Table, clinic.Columns, sqlgraph.NewFieldSpec(clinic.FieldID, field.TypeUUID))
	id, ok := cuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`db: missing "Clinic.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := cuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, clinic.FieldID)
		for _, f := range fields {
			if !clinic.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("db: invalid field %q for query", f)}
			}
			if f != clinic.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := cuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := cuo.mutation.Name(); ok {
		_spec.SetField(clinic.FieldName, field.TypeString, value)
	}
	if value, ok := cuo.mutation.GetType(); ok {
		_spec.SetField(clinic.FieldType, field.TypeString, value)
	}
	if value, ok := cuo.mutation.Phone(); ok {
		_spec.SetField(clinic.FieldPhone, field.TypeString, value)
	}
	if cuo.mutation.PhoneCleared() {
		_spec.ClearField(clinic.FieldPhone, field.TypeString)
	}
	if value, ok := cuo.mutation.Email(); ok {
		_spec.SetField(clinic.FieldEmail, field.TypeString, value)
	}
	if cuo.mutation.EmailCleared() {
		_spec.ClearField(clinic.FieldEmail, field.TypeString)
	}
	if value, ok := cuo.mutation.Address(); ok {
		_spec.SetField(clinic.FieldAddress, field.TypeString, value)
	}
	if cuo.mutation.AddressCleared() {
		_spec.ClearField(clinic.FieldAddress, field.TypeString)
	}
	if value, ok := cuo.mutation.BusinessHours(); ok {
		_spec.SetField(clinic.FieldBusinessHours, field.TypeJSON, value)
	}
	if cuo.mutation.BusinessHoursCleared() {
		_spec.ClearField(clinic.FieldBusinessHours, field.TypeJSON)
	}
	if value, ok := cuo.mutation.WhatsappNumber(); ok {
		_spec.SetField(clinic.FieldWhatsappNumber, field.TypeString, value)
	}
	if cuo.mutation.WhatsappNumberCleared() {
		_spec.ClearField(clinic.FieldWhatsappNumber, field.TypeString)
	}
	if value, ok := cuo.mutation.SubscriptionPlan(); ok {
		_spec.SetField(clinic.FieldSubscriptionPlan, field.TypeString, value)
	}
	if value, ok := cuo.mutation.EnabledFeatures(); ok {
		_spec.SetField(clinic.FieldEnabledFeatures, field.TypeJSON, value)
	}
	if value, ok := cuo.mutation.AppendedEnabledFeatures(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, clinic.FieldEnabledFeatures, value)
		})
	}
	if value, ok := cuo.mutation.Active(); ok {
		_spec.SetField(clinic.FieldActive, field.TypeBool, value)
	}
	if value, ok := cuo.mutation.CreatedAt(); ok {
		_spec.SetField(clinic.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := cuo.mutation.UpdatedAt(); ok {
		_spec.SetField(clinic.FieldUpdatedAt, field.TypeTime, value)
	}
	if cuo.mutation.ClinicUsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ClinicUsersTable,
			Columns: []string{clinic.ClinicUsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(clinicuser.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedClinicUsersIDs(); len(nodes) > 0 && !cuo.mutation.ClinicUsersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ClinicUsersTable,
			Columns: []string{clinic.ClinicUsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(clinicuser.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.ClinicUsersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ClinicUsersTable,
			Columns: []string{clinic.ClinicUsersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(clinicuser.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.PatientsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.PatientsTable,
			Columns: []string{clinic.PatientsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(patient.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedPatientsIDs(); len(nodes) > 0 && !cuo.mutation.PatientsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.PatientsTable,
			Columns: []string{clinic.PatientsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(patient.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.PatientsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.PatientsTable,
			Columns: []string{clinic.PatientsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(patient.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.DoctorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DoctorsTable,
			Columns: []string{clinic.DoctorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(doctor.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedDoctorsIDs(); len(nodes) > 0 && !cuo.mutation.DoctorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DoctorsTable,
			Columns: []string{clinic.DoctorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(doctor.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.DoctorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DoctorsTable,
			Columns: []string{clinic.DoctorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(doctor.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.ServicesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ServicesTable,
			Columns: []string{clinic.ServicesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(service.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedServicesIDs(); len(nodes) > 0 && !cuo.mutation.ServicesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ServicesTable,
			Columns: []string{clinic.ServicesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(service.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.ServicesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ServicesTable,
			Columns: []string{clinic.ServicesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(service.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.AppointmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.AppointmentsTable,
			Columns: []string{clinic.AppointmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(appointment.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedAppointmentsIDs(); len(nodes) > 0 && !cuo.mutation.AppointmentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.AppointmentsTable,
			Columns: []string{clinic.AppointmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(appointment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.AppointmentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.AppointmentsTable,
			Columns: []string{clinic.AppointmentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(appointment.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.ChatThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ChatThreadsTable,
			Columns: []string{clinic.ChatThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chatthread.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedChatThreadsIDs(); len(nodes) > 0 && !cuo.mutation.ChatThreadsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ChatThreadsTable,
			Columns: []string{clinic.ChatThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chatthread.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.ChatThreadsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ChatThreadsTable,
			Columns: []string{clinic.ChatThreadsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(chatthread.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.KnowledgeBaseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.KnowledgeBaseTable,
			Columns: []string{clinic.KnowledgeBaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(knowledgebase.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedKnowledgeBaseIDs(); len(nodes) > 0 && !cuo.mutation.KnowledgeBaseCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.KnowledgeBaseTable,
			Columns: []string{clinic.KnowledgeBaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(knowledgebase.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.KnowledgeBaseIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.KnowledgeBaseTable,
			Columns: []string{clinic.KnowledgeBaseColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(knowledgebase.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.BillingRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.BillingRecordsTable,
			Columns: []string{clinic.BillingRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billingrecord.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedBillingRecordsIDs(); len(nodes) > 0 && !cuo.mutation.BillingRecordsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.BillingRecordsTable,
			Columns: []string{clinic.BillingRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billingrecord.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.BillingRecordsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.BillingRecordsTable,
			Columns: []string{clinic.BillingRecordsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(billingrecord.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.DocumentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DocumentsTable,
			Columns: []string{clinic.DocumentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(document.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedDocumentsIDs(); len(nodes) > 0 && !cuo.mutation.DocumentsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DocumentsTable,
			Columns: []string{clinic.DocumentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(document.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.DocumentsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.DocumentsTable,
			Columns: []string{clinic.DocumentsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(document.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.ProductsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductsTable,
			Columns: []string{clinic.ProductsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(product.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedProductsIDs(); len(nodes) > 0 && !cuo.mutation.ProductsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductsTable,
			Columns: []string{clinic.ProductsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(product.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.ProductsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductsTable,
			Columns: []string{clinic.ProductsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(product.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.ProductCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductCategoriesTable,
			Columns: []string{clinic.ProductCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productcategory.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedProductCategoriesIDs(); len(nodes) > 0 && !cuo.mutation.ProductCategoriesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductCategoriesTable,
			Columns: []string{clinic.ProductCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productcategory.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.ProductCategoriesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.ProductCategoriesTable,
			Columns: []string{clinic.ProductCategoriesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(productcategory.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.InventoryMovementsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.InventoryMovementsTable,
			Columns: []string{clinic.InventoryMovementsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inventorymovement.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedInventoryMovementsIDs(); len(nodes) > 0 && !cuo.mutation.InventoryMovementsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.InventoryMovementsTable,
			Columns: []string{clinic.InventoryMovementsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inventorymovement.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.InventoryMovementsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.InventoryMovementsTable,
			Columns: []string{clinic.InventoryMovementsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(inventorymovement.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if cuo.mutation.OrdersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.OrdersTable,
			Columns: []string{clinic.OrdersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(order.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.RemovedOrdersIDs(); len(nodes) > 0 && !cuo.mutation.OrdersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.OrdersTable,
			Columns: []string{clinic.OrdersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(order.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := cuo.mutation.OrdersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   clinic.OrdersTable,
			Columns: []string{clinic.OrdersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(order.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Clinic{config: cuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, cuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{clinic.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	cuo.mutation.done = true
	return _node, nil
}
